### 1 WHERE 和 HAVING

1. WHERE过滤行，HAVING过滤分组
2. WHERE在分组之前过滤数据，HAVING在分组之后过滤数据



### 2 mysql如何保证事务的原子性

原子性也就是说，事务中的语句，要么都完成，要么都不完成，一个事务就像是一个原子操作一样。那么既然要保证原子性，首先要考虑原子性是如何被破坏的。如果事务提交了，并写入磁盘了，这个事务就结束了，原子性是没问题的。破坏原子性的场景：

1. 事务未提交，发生宕机。
2. 事务已提交，但还未来得及写入磁盘，发生宕机。

对于前一种情况，应该将事务回滚，对于后一种情况，则应该将事务重做。

在mysql中，提供了undo log和redo log，分别用来执行回滚和前滚。在mysql恢复时，首先按照redo log从checkpoint开始重新执行所有事务，这样可以保证已提交但未写入的事务的原子性。然后再按照undo log，将未提交的事务回滚至初始状态，保证了未提交事务的原子性。

上述机制同样可以保证事务的持久性。



### 3 mysql如何解决脏读和幻读

1. 脏读就是在RU隔离级别下读到其他事务未提交的数据。

   解决办法是将隔离级别设为RC。

   底层原理是MVCC，控制了SELECT语句只能读到版本号小于等于当前版本且删除版本号大于当前版本的数据。

   RC和RR的MVCC区别是：RC的每一条DML语句会产生一个新的快照，而RR在事务的第一条DML语句产生一个快照，用到事务结束。

2. 幻读就是指在范围读取的时候两次读取结果不一致的情况。

   mysql的RR级别解决了幻读。

   在mysql中有两种解决幻读的方式，MVCC（快照读），next-key（当前读）。

   - 使用MVCC时，由于读取的是快照中的内容，当然不会产生幻读。
   - 使用next-key时，要求读取当前数据内容。会用到行锁（锁住读取的行）和间隙锁（锁住行和前后行之间的间隙），这样也就意味着范围数据的整个范围被锁住，无法插入或删除数据，避免了幻读。
   - next-key的锁是加在索引上的，若没有索引，则需要锁住全表。



